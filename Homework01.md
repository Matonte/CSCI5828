# CSCI 5828
# Homework #1
## Matt Weber

 1. Essential Difficulties are problems that arise in software engineering that are inherent to software itself; they lie within the fundamental processes of producing software. An example would be trying to scope and define a software system based on requirements gathered from various vested groups. This would be an essential difficulty as it relates to a core component of the software development process.
 
 2. Accidental Difficulties are challenges and problems that arise as part of the software engineering process and the production of software. These difficulties focus more on HOW the software is created, and references the tools and processes engineers may use to generate software. An example would be using an optimized compiler for a project that increases performance but requires sections of the program to be rewritten into a new programming language. This rework of the program due to the new compiler would be an accidental difficulty; it was introduced by a new tool.
 3. The 4 Essential Difficulties are complexity, conformity, changeability, and invisibility.
	 - Complexity - Software itself is complex, but software systems can be magnitudes higher in complexity, and this seems to be trending upwards.  This nature of software leads to difficulties simply because there are so many "moving parts" within a software system. An example would be a full network stack, with support for various HBA types and conversion to a common format for processing I/O. Designing, developing, and maintaining such software is difficult, and the complexity is a major factor.
	 - Conformity - A lot of complexity in software is due to having to conform to various outside influences and factors. There are specifications, requirements, shareholder requests, legacy support, feature evolution that require software to be adapted and grown. This inherently leads to difficulties as many times the requests can be arbitrary and unpredictable. An example of conformity is updating a software system to handle new requirements as part of a revised interface specification. It is impossible for software to be forward-compatible when new specification is unknown, so conforming software to new requirements will always be a challenge.
	 - Changeability - Software is viewed as easily changed, and ever-updating requirements require constant turnover of code. 
This lack of a static status is a factor of many difficulties, as constant change is not only difficult to implement, but it introduces the risk of adding instability to the software system as well.  An example of changeability is the constant patches and updates many applications are required to receive in order to support various different devices, especially in the mobile segment of software.
	 - Invisibility - Software is not easily visualized; it is extremely hard to graphically represent an entire software system.  This is a basic cause of many difficulties - we simply cannot see all the parts and states at once, there is no way to lay out a system and encapsulate all the needed information.  An example of this is the fact that there are so many different UML diagrams, each needed to convey some aspect of a software system, but there is no "primary" diagram that can capture all the information at once. I may have one UML diagram that captures the various states of the system, but I would need a separate diagram to visualize the relationships between the classes and variables in the system.
 4. Brooks defines a silver bullet as a single technique or technology that by itself can deliver one order-of-magnitude improvement to some aspect of software development. He believes that no such silver bullet exists, as essential difficulties are an underlying factor in software engineering inefficiency, and most attempts at significant improvement in software engineering do not actually address essential difficulties, but rather accidental difficulties that arise as part of the software engineering process. While there may be efforts to solve essential difficulties, there will never be a single solution that provides the level of improvement referenced.
 5. Software Engineering is defined as using a disciplined, structured approach to generate solutions to software problems. Its comparison to computer science is that it takes the knowledge, discovery and theory produced by computer science and applies it in meaningful and beneficial ways via products and solutions.  Much like how a chemist researches and studies chemicals and a chemical engineer is focused on applying these findings in practical ways, software engineering differs from computer science in that its focus is on the application of computer science into meaningful and practical applications.  
 6. 5 software engineering concepts are specification, translation, iteration, abstractions and conversations. The core principles of software engineering are specification, translation, and iteration.
	- Specification is used to define specific parameters and requirements for every aspect of software engineering.  It makes collaboration easier, and helps drive clean APIs for faster integration of various components. It also makes creating software more intuitive and easier to learn and share.
	- Translation is the main work of software engineering, to translate data/work from one specification to the next. A good example is a network stack, translating from the physical layer up through various layers to produce intended results. Translation is used to leverage abstractions at various levels of a software product.
	- Iteration is how the work of software engineering is executed; it allows a software product to be created one step at a time, producing meaningful results more efficiently.  Agile and iterative development methodologies are built around this concept.
	
	The primary tools used for software engineering are abstractions and conversations. 
	- Abstractions are a way of taking a complex set of steps and processes and breaking them down into understandable parts that can can be developed as part of a complete system. APIs are developed as a way of translating abstractions at one layer of a software program to the next.  This allows various components to operate without needing to be aware of how every other component works.
	- Conversations and communication is the key to developing good software.  Understanding requirements, interacting with other developers, components, etc all requires conversations in order to successfully drive a software project. Proper documentation and scoping leads to a more efficient software development process and better overall product at the end.

